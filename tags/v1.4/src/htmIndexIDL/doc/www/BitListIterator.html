<html><head><TITLE>BitListIterator</TITLE></head>
 <body text="#111111" bgcolor="#FFFFFF" link="#333399" vlink="#663366" alink="#CC0000">

<h3>&nbsp;&nbsp;
<font color="#7700EE">HTM SpatialIndex Class Reference</font>
</h3>
<img SRC="rule.gif" >


<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  BitListIterator  </H2><BLOCKQUOTE>
BitListIterator class
</BLOCKQUOTE>
<hr>

<DL>
<TABLE BORDER>
<DT><h3>Public Methods</h3><DD><TR><TD VALIGN=top><A HREF="#DOC.18.6"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>BitListIterator</B> ()<br>
<I> Default Constructor.</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.1"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>BitListIterator</B> (const <!1><A HREF="BitList.html">BitList</A> & <!2><A HREF="BitListIterator.html#DOC.18.13">bitlist</A>)<br>
<I>Normal Constructor</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.2"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>BitListIterator</B> (const <!1><A HREF="BitList.html">BitList</A> & <!2><A HREF="BitListIterator.html#DOC.18.13">bitlist</A>, size_t start)<br>
<I>Alternate constructor</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.7"> <IMG BORDER=0 SRC=icon1.gif></A> </TD><TD><B>BitListIterator</B> (const <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A> &)<br>
<I> Copy Constructor.</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.8"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A>& </TD><TD><B>operator = </B> (const <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A> &)<br>
<I> Assignment.</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.9"> <IMG BORDER=0 SRC=icon1.gif></A> void </TD><TD><B>setindex</B> (size_t index)<br>
<I> Init: set current index</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.3"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>next</B> (bool bit, size_t & _index)<br>
<I>Set the internal index to the next 'true' or 'false' bit;
indicated by the first argument, and return the index in the
second argument</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.10"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>prev</B> (bool bit, size_t & _index)<br>
<I> Just like next(), but the index is moved backwards.</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.4"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>next</B> (bool & bit)<br>
<I>Increment the internal index and return the value of the bit it points to
Returns 'false' if the boundary is reached</I>
</TD></TR><TR><TD VALIGN=top><A HREF="#DOC.18.5"> <IMG BORDER=0 SRC=icon1.gif></A> bool </TD><TD><B>prev</B> (bool & bit)<br>
<I>Just like next() above, just decrement the internal index</I>
</TD></TR></TABLE></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>
BitListIterator class.
The BitListIterator iterates through a BitList efficiently.
next() and prev() functions are supplied. The functionality is
the following: The BLI saves an index to a certain bit in the BitList.
By calling either next() or prev(), the index is incremented/decremented and
the bit it is pointing to now is returned. If it gets out of bounds,
these functions return 'false'. The out-of-bounds index is always 
index=size. So by calling next() or prev() again when a 'false' was 
returned previously, they return the first/last bit, respectively.

</BLOCKQUOTE>
<DL>

<A NAME="BitListIterator">
<A NAME ="DOC.18.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  BitListIterator()</B></TT>
<DD> Default Constructor.
<DL></DL><P>
<A NAME="BitListIterator">
<A NAME ="DOC.18.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  BitListIterator(const <!1><A HREF="BitList.html">BitList</A> & <!2><A HREF="BitListIterator.html#DOC.18.13">bitlist</A>)</B></TT>
<DD>Normal Constructor.
needs the BitList to initialize.
The index is initialized to the out-of-bounds index. 
<DL></DL><P>
<A NAME="BitListIterator">
<A NAME ="DOC.18.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  BitListIterator(const <!1><A HREF="BitList.html">BitList</A> & <!2><A HREF="BitListIterator.html#DOC.18.13">bitlist</A>, size_t start)</B></TT>
<DD>Alternate constructor.
set the starting index yourself. 
<DL></DL><P>
<A NAME="BitListIterator">
<A NAME ="DOC.18.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  BitListIterator(const <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A> &)</B></TT>
<DD> Copy Constructor.
<DL></DL><P>
<A NAME="operator = ">
<A NAME ="DOC.18.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A>&  operator = (const <!2><A HREF="BitListIterator.html#DOC.18.6">BitListIterator</A> &)</B></TT>
<DD> Assignment.
<DL></DL><P>
<A NAME="setindex">
<A NAME ="DOC.18.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setindex(size_t index)</B></TT>
<DD> Init: set current index
<DL></DL><P>
<A NAME="next">
<A NAME ="DOC.18.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  next(bool bit, size_t & _index)</B></TT>
<DD>Set the internal index to the next 'true' or 'false' bit;
indicated by the first argument, and return the index in the
second argument.  Returns 'false' if it gets out of bounds.
Example: For a BitList 001100110011 (from left to right, index
starts at 0), the subsequent call to next(true,index) returns
'true' and sets index to 2, 3, 6, 7, 10, 11. The next call puts
leaves index and returns 'false'. A subsequent next() call would
again return 'true' and set index=2.
<DL></DL><P>
<A NAME="prev">
<A NAME ="DOC.18.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  prev(bool bit, size_t & _index)</B></TT>
<DD> Just like next(), but the index is moved backwards.
<DL></DL><P>
<A NAME="next">
<A NAME ="DOC.18.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  next(bool & bit)</B></TT>
<DD>Increment the internal index and return the value of the bit it points to
Returns 'false' if the boundary is reached.
<b>Example</b>: For a BitList 001100110011 the calls to next(val) return
'true' and set bit to 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1. The next call
returns 'false' and does not set bit. A subsequent call would return
again 'true' and set bit to the first bit in the list, in this case 0.
<DL></DL><P>
<A NAME="prev">
<A NAME ="DOC.18.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool  prev(bool & bit)</B></TT>
<DD>Just like next() above, just decrement the internal index.
The two versions of next() and prev() may be used in conjunction.
<DL></DL><P></DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>

<img SRC="rule.gif" >
<h6>
&copy;
<A HREF = "http://www.sdss.jhu.edu/ScienceArchive/copyright.html">
Copyright
</A>
The Johns Hopkins University 1999, All Rights Reserved.<br>

<a href="mailto:kunszt@pha.jhu.edu">Peter Z. Kunszt</a>,
<br>
</h6>

</body>
</html>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
