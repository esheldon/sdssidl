<html>
<!-- This file is generated automatically; modifications will be lost -->
<!-- Generated by cxx2html version 1.2PL2 -->
<!-- Created by user kunszt at 1999/10/19 17:59:40 -->
<head>
<title> VarVec.h </title>
</head>
<body text="#111111" bgcolor="#FFFFFF" link="#333399" vlink="#663366" alink="#CC0000">
<h1><font color="#7700EE"> VarVec.h </font></h1><img src="rule.gif"><br><br>
<h1>Classes</h1>
<dl>
<dd> <a href="#ValVec"> ValVec </a> -- dynamic array of arbitrary values (<em><a href="#ValVec:description">full description</a></em>)
<dd> <a href="#PtrVec"> PtrVec </a> -- dynamic array of pointers (<em><a href="#PtrVec:description">full description</a></em>)
<dd> <a href="#LinPool"> LinPool </a> -- dynamic linear pool of objects. (<em><a href="#LinPool:description">full description</a></em>)
</dl>
<hr>

<h1>template&lt;class T&gt; class <a name="ValVec" href="../../include/VarVec.h">ValVec</a> </h1>
<h1>Interface</h1>
<dl>
<dd> <b>Public Members</b>

<dl>

<dd> <a href="#ValVec:~ValVec(void)">~ValVec</a>( void )
<dd> <a href="#ValVec:ValVec(size_t,size_t)">ValVec</a>( size_t capacity = 0, size_t increment = 0 )
<dd> <a href="#ValVec:ValVec(const,size_t,size_t)">ValVec</a>( const T &amp;fill, size_t capacity, size_t increment )
<dd> <a href="#ValVec:ValVec(const)">ValVec</a>( const ValVec&amp; )
<dd> ValVec&amp;	<a href="#ValVec:operator=(const)">operator =</a>( const ValVec&amp; )
<dd> const T&amp;	<a href="#ValVec:operator()(size_t)const">operator ()</a>( size_t index ) const
<dd> T&amp; <a href="#ValVec:operator()(size_t)">operator ()</a>( size_t index )
<dd> const T&amp;	<a href="#ValVec:operator[](size_t)const">operator []</a>( size_t index ) const
<dd> T&amp; <a href="#ValVec:operator[](size_t)">operator []</a>( size_t index )
<dd> T&amp; <a href="#ValVec:at(size_t)">at</a>( size_t index )
<dd> size_t	<a href="#ValVec:length(void)const">length</a>( void ) const
<dd> size_t	<a href="#ValVec:append(const)">append</a>( const T&amp; )
<dd> size_t	<a href="#ValVec:insert(size_t,size_t)">insert</a>( size_t count, size_t offset = 0 )
<dd> size_t	<a href="#ValVec:cut(size_t,size_t)">cut</a>( size_t count, size_t offset = 0 )
<dd> void <a href="#ValVec:remove(size_t)">remove</a>( size_t offset )
<dd> size_t	<a href="#ValVec:keep(size_t)">keep</a>( size_t count )
<dd> T&amp; <a href="#ValVec:fill(void)">fill</a>( void )
<dd> bool <a href="#ValVec:fillExists(void)const">fillExists</a>( void ) const
<dd> void <a href="#ValVec:unsetFill(void)">unsetFill</a>( void )
<dd> void <a href="#ValVec:clear(void)">clear</a>( void )
</dl>
</dl>
<h1><a name="ValVec:description">Description</a></h1>

<p>
<p>
 This is a template for a general-purpose dynamic array.  The array
 grows automatically as needed, but reallocation occurs only when
 the length exceeds the capacity.  The capacity is increased in
 large blocks, the size of which may be optimized.  A fill value may
 be defined, in which case it is used to initialize new elements of
 the array, but not new capacity.  Which is to say that
 initialization is deferred until the array grows into its capacity.
 The public data member, increment_, specifies the amount by which
 the capacity is increased during reallocation.  By default,
 increment_ is zero, which causes the capacity to double upon each
 reallocation.  A non-zero increment_ is simply added to the
 capacity upon each reallocation.  The capacity is extended by this
 amount or by whatever greater amount is necessary to accommodate
 the new length of the array.
<h1>Member Description</h1>
<h3><a name="ValVec:~ValVec(void)">~ValVec</a>( void )</h3>
 Destructor.
<p>
<h3><a name="ValVec:ValVec(size_t,size_t)">ValVec</a>( size_t capacity = 0, size_t increment = 0 )</h3>
<p>
 Default constructor: optionally specify initial capacity and
 reallocation increment.
<p>
<h3><a name="ValVec:ValVec(const,size_t,size_t)">ValVec</a>( const T &amp;fill, size_t capacity, size_t increment )</h3>
<p>
 Alternate constructor: define a fill value in addition to the
 parameters of the default constructor.  class T must have
 well-defined copy semantics.  The fill value does not exist
 unless it is defined.
<p>
<h3><a name="ValVec:ValVec(const)">ValVec</a>( const ValVec&amp; )</h3>
<p>
 Copy constructor.  The initial capacity is the current capacity
 of the duplicated array.
<p>
<h3>ValVec&amp;	<a name="ValVec:operator=(const)">operator =</a>( const ValVec&amp; )</h3>
<p>
 Assignment/copy operator: does not decrease the capacity.
<p>
<h3>const T&amp;	<a name="ValVec:operator()(size_t)const">operator ()</a>( size_t index ) const</h3>
<p>
 Efficient array operator (const version): no bounds checking.
<p>
<h3>T&amp; <a name="ValVec:operator()(size_t)">operator ()</a>( size_t index )</h3>
<p>
<p>
 Efficient array operator (non-const version): no bounds checking.
<p>
<h3>const T&amp;	<a name="ValVec:operator[](size_t)const">operator []</a>( size_t index ) const</h3>
<p>
<p>
 Bounds-checking array operator (const version): throws sxBoundsError.
<p>
<h3>T&amp; <a name="ValVec:operator[](size_t)">operator []</a>( size_t index )</h3>
<p>
 Bounds-checking array operator (non-const version): throws sxBoundsError.
<p>
<h3>T&amp; <a name="ValVec:at(size_t)">at</a>( size_t index )</h3>
<p>
 at method: bounds-adjusting array operator.  Returns the array
 element at the specified index, extending the array as necessary
 to bring it within bounds.  The fill value, if defined, is the
 initializer for any new elements.
<p>
<h3>size_t	<a name="ValVec:length(void)const">length</a>( void ) const</h3>
<p>
 length method: returns current occupied length of array.
<p>
<h3>size_t	<a name="ValVec:append(const)">append</a>( const T&amp; )</h3>
<p>
<p>
 append method: efficiently insert given element at end of array.
 Avoids redundant initialization of new array element, except for
 when a reallocation is required.  Returns the new length.
<p>
<h3>size_t	<a name="ValVec:insert(size_t,size_t)">insert</a>( size_t count, size_t offset = 0 )</h3>
<p>
 insert method: insert new array elements.  count specifies the
 number of new elements, and offset specifies where in the array
 to insert them.  By default the new elements are appended.  The
 fill value, if defined, is the initializer for the new elements.
 offset refers to the end of the array: the first new element is
 located at index (length - offset).  Returns the new length.
 Throws sxBoundsError if offset is greater than length.
<p>
<h3>size_t	<a name="ValVec:cut(size_t,size_t)">cut</a>( size_t count, size_t offset = 0 )</h3>
<p>
 cut method: remove array elements.  count specifies the number
 of elements to remove, and offset specifies which elements to
 remove.  By default elements are removed from the end of the
 array.  The unused capacity grows by this amount.  offset refers
 to the end of the array: the first removed element is located at
 index (length - offset - count).  Returns the new length.
 Throws sxBoundsError if (offset+count) is greater than length.
<p>
<h3>void <a name="ValVec:remove(size_t)">remove</a>( size_t offset )</h3>
<p>
 remove method: removes the element specified by offset.
 This is basically a wrapper for the cut method cut(1, length-offset-1)
<p>
<h3>size_t	<a name="ValVec:keep(size_t)">keep</a>( size_t count )</h3>
<p>
 keep method: just like the cut method, it resets the length of
 the vector by count, but it always starts from the end.
 The elements, however are not deleted and rebuilt with the
 default, but rather left as they are for the user to reuse.
<p>
<h3>T&amp; <a name="ValVec:fill(void)">fill</a>( void )</h3>
<p>
 fill method: return the fill value, defining it if necessary.
 If the fill value is not defined, a default value is created
 using the default constructor for class T.  The returned object
 is an lvalue, to which a new fill value may be assigned.
<p>
<h3>bool <a name="ValVec:fillExists(void)const">fillExists</a>( void ) const</h3>
<p>
 fillExists method: returns true if the fill value is defined.
<p>
<h3>void <a name="ValVec:unsetFill(void)">unsetFill</a>( void )</h3>
<p>
 unsetFill method: undefine and destroy the current fill value,
 if it is defined.
<p>
<h3>void <a name="ValVec:clear(void)">clear</a>( void )</h3>
<p>
<p>
 clear method: reset every value to the fill value. If no fill is
 defined, nothing is done!
<p>
<hr>

<h1>template&lt;class T&gt; class <a name="PtrVec" href="../../include/VarVec.h">PtrVec</a> </h1>
<h1>Interface</h1>
<dl>
<dd> <a href="#PtrVec:~PtrVec(void)">~PtrVec</a>( void )
<dd> <a href="#PtrVec:PtrVec(bool,size_t,size_t)">PtrVec</a>( bool internal=true, size_t capacity=0, size_t increment=0 )
<dd> <a href="#PtrVec:PtrVec(const,bool)">PtrVec</a>( const PtrVec&amp;, bool internalize = true )
<dd> PtrVec&amp;	<a href="#PtrVec:copy(const,bool)">copy</a>( const PtrVec&amp;, bool internalize )
<dd> PtrVec&amp;	<a href="#PtrVec:operator=(const)">operator =</a>( const PtrVec &amp;obj )
<dd> const T*&amp;	<a href="#PtrVec:operator()(size_t)const">operator ()</a>( size_t index ) const
<dd> T*&amp; <a href="#PtrVec:operator()(size_t)">operator ()</a>( size_t index )
<dd> const T*&amp;	<a href="#PtrVec:operator[](size_t)const">operator []</a>( size_t index ) const
<dd> T*&amp; <a href="#PtrVec:operator[](size_t)">operator []</a>( size_t index )
<dd> T*&amp; <a href="#PtrVec:at(size_t)">at</a>( size_t index )
<dd> size_t	<a href="#PtrVec:length(void)const">length</a>( void ) const
<dd> size_t	<a href="#PtrVec:entries(void)const">entries</a>( void ) const
<dd> size_t	<a href="#PtrVec:append(T*)">append</a>( T* )
<dd> size_t	<a href="#PtrVec:insert(size_t,size_t)">insert</a>( size_t count, size_t offset = 0 )
<dd> size_t	<a href="#PtrVec:add(T*)">add</a>( T* )
<dd> int <a href="#PtrVec:index(const)">index</a>( const T* )
<dd> size_t	<a href="#PtrVec:cut(size_t,size_t)">cut</a>( size_t count, size_t offset = 0 )
<dd> void <a href="#PtrVec:internalize(void)">internalize</a>( void )
<dd> void <a href="#PtrVec:externalize(void)">externalize</a>( void )
<dd> bool <a href="#PtrVec:internal(void)const">internal</a>( void ) const
</dl>
</dl>
<h1><a name="PtrVec:description">Description</a></h1>

<p>
<p>
 This is a template for a dynamic array of pointers.  The design is
 very similar to the general-purpose version, ValVec, but
 specialized according to the memory management issues peculiar to
 storing pointers.  This version uses nil as the fill value, which
 cannot be customized or disabled.  By default, the cut method uses
 the delete operator to free pointers as they are removed from the
 array.  Before disposing the array, the destructor clears it out
 with cut.  This behavior is avoided if the pointers are designated
 as external, or shared.  In that case it is entirely up to the user
 to free pointers left dangling by cut.  When copying the array, one
 must choose whether the copy will share with the original the
 objects referenced by the pointers (shallow copy), or whether the
 copy will have its own internal duplicates.
<p>
           ---------------   WARNING   ---------------
<p>
 The user must provide a specialization of PtrDup() for every
 polymorphic class that will instantiate this template.  Failure to
 do this may result in unexpected truncation of derived objects.
 The template methods use PtrDup() when duplication of objects is
 required, but duplicating a polymorphic object requires assistance
 from the object itself.  For example, consider class B:
<p>
 class B { public:
  virtual B* duplicate(void) const = 0;
 };
 inline B* PtrDup(const B *b) { return b ? b->duplicate() : 0; }
<p>
 To avoid confusion and mistakes, place the specialization
 immediately after the declaration of class B.  If class B does not
 have a duplicator use the following specialization instead:
<p>
 inline B* PtrDup(const B *b) {
  if (b) throw sxUnimplemented("PtrDup","class B has no duplicator");
  else return 0;
 }
<h1>Member Description</h1>
<h3><a name="PtrVec:~PtrVec(void)">~PtrVec</a>( void )</h3>
 Destructor.
<p>
<h3><a name="PtrVec:PtrVec(bool,size_t,size_t)">PtrVec</a>( bool internal=true, size_t capacity=0, size_t increment=0 )</h3>
<p>
 Default constructor: optionally specify initial capacity,
 reallocation increment, and whether the pointers are internal.
<p>
<h3><a name="PtrVec:PtrVec(const,bool)">PtrVec</a>( const PtrVec&amp;, bool internalize = true )</h3>
<p>
 Copy constructor: optionally specify either a shallow copy or an
 internalized copy (the default).  The initial capacity is the
 current capacity of the duplicated array.
<p>
<h3>PtrVec&amp;	<a name="PtrVec:copy(const,bool)">copy</a>( const PtrVec&amp;, bool internalize )</h3>
<p>
 copy method: does not decrease the capacity.  The copy is
 shallow if internalize is false; otherwise the referenced
 objects are duplicated and the copy is internal, in which case
 class T must have well-defined copy semantics.
<p>
<h3>PtrVec&amp;	<a name="PtrVec:operator=(const)">operator =</a>( const PtrVec &amp;obj )</h3>
<p>
 Assignment/copy operator: does not decrease the capacity.  This
 is not a shallow copy, so class T must have well-defined copy
 semantics.
<p>
<h3>const T*&amp;	<a name="PtrVec:operator()(size_t)const">operator ()</a>( size_t index ) const</h3>
<p>
<p>
 Efficient array operator (const version): no bounds checking.
<p>
<h3>T*&amp; <a name="PtrVec:operator()(size_t)">operator ()</a>( size_t index )</h3>
<p>
<p>
 Efficient array operator (non-const version): no bounds checking.
<p>
<h3>const T*&amp;	<a name="PtrVec:operator[](size_t)const">operator []</a>( size_t index ) const</h3>
<p>
<p>
 Bounds-checking array operator (const version): throws sxBoundsError.
<p>
<h3>T*&amp; <a name="PtrVec:operator[](size_t)">operator []</a>( size_t index )</h3>
<p>
 Bounds-checking array operator (non-const version): throws sxBoundsError.
<p>
<h3>T*&amp; <a name="PtrVec:at(size_t)">at</a>( size_t index )</h3>
<p>
 at method: bounds-adjusting array operator.  Returns the array
 element at the specified index, extending the array as necessary
 to bring it within bounds.  Any new elements are set to nil.
<p>
<h3>size_t	<a name="PtrVec:length(void)const">length</a>( void ) const</h3>
<p>
 length method: returns current occupied length of array.
<p>
<h3>size_t	<a name="PtrVec:entries(void)const">entries</a>( void ) const</h3>
<p>
<p>
 entries method: return the number of non-NULL entries in vector
 NOTE: this is different from length(), which also counts NULL pointers.
<p>
<h3>size_t	<a name="PtrVec:append(T*)">append</a>( T* )</h3>
<p>
 append method: efficiently insert given element at end of array.
 Avoids redundant initialization of new array element, except for
 when a reallocation is required.  Returns the new length.
<p>
<h3>size_t	<a name="PtrVec:insert(size_t,size_t)">insert</a>( size_t count, size_t offset = 0 )</h3>
<p>
 insert method: insert new array elements.  count specifies the
 number of new elements, and offset specifies where in the array
 to insert them.  By default the new elements are appended.  The
 new elements are initialized with the nil pointer value.  offset
 refers to the end of the array: the first new element is located
 at index (length - offset).  Returns the new length.  Throws
 sxBoundsError if offset is greater than length.
<p>
<h3>size_t	<a name="PtrVec:add(T*)">add</a>( T* )</h3>
<p>
 add method: add a new array element in the first available
 empty slot.  This should be used when the ordering of elements
 is not important and empty slots are to be minimized.  Returns the
 index of the newly inserted element.
<p>
<h3>int <a name="PtrVec:index(const)">index</a>( const T* )</h3>
<p>
 index method: return the index of the given element if it exists in
 the array, else return -1.
<p>
<h3>size_t	<a name="PtrVec:cut(size_t,size_t)">cut</a>( size_t count, size_t offset = 0 )</h3>
<p>
 cut method: remove array elements.  count specifies the number
 of elements to remove, and offset specifies which elements to
 remove.  By default elements are removed from the end of the
 array.  The unused capacity grows by this amount.  offset refers
 to the end of the array: the first removed element is located at
 index (length - offset - count).  Returns the new length.
 Throws sxBoundsError if (offset+count) is greater than length.
<p>
<h3>void <a name="PtrVec:internalize(void)">internalize</a>( void )</h3>
<p>
 internalize method: replace external pointers with internal
 copies of the referenced objects.  class T must have
 well-defined copy semantics.  Does nothing if already internal.
<p>
<h3>void <a name="PtrVec:externalize(void)">externalize</a>( void )</h3>
<p>
 externalize method: change status of pointers to external.
 Beware that internalize does not undo this; once the pointers
 are designated external they cannot just be re-designated as
 internal.  Confusion on this point will yield dangling pointers.
<p>
<h3>bool <a name="PtrVec:internal(void)const">internal</a>( void ) const</h3>
<p>
 internal method: returns true if the pointers are internal.
<p>
<hr>

<h1>template&lt;class T&gt; class <a name="LinPool" href="../../include/VarVec.h">LinPool</a> </h1>
<h1>Interface</h1>
<dl>
<dd> <a href="#LinPool:~LinPool(void)">~LinPool</a>( void )
<dd> <a href="#LinPool:LinPool(size_t,size_t)">LinPool</a>( size_t capacity=0, size_t increment=0 )
<dd> const T*&amp;	<a href="#LinPool:operator()(size_t)const">operator ()</a>( size_t index ) const
<dd> T*&amp; <a href="#LinPool:operator()(size_t)">operator ()</a>( size_t index )
<dd> const T*&amp;	<a href="#LinPool:operator[](size_t)const">operator []</a>( size_t index ) const
<dd> T*&amp; <a href="#LinPool:operator[](size_t)">operator []</a>( size_t index )
<dd> T*&amp; <a href="#LinPool:use(void)">use</a>( void )
<dd> size_t	<a href="#LinPool:length(void)const">length</a>( void ) const
<dd> size_t	<a href="#LinPool:free(size_t)">free</a>( size_t count = 0)
</dl>
</dl>
<h1><a name="LinPool:description">Description</a></h1>

<p>
<p>
<p>
 This is a template for a dynamic pool of objects.  The design is
 very similar to the dynamic array of pointers.  A pool is defined
 to be an array of pointers to preallocated default objects.
 Whenever a new object is needed, it can be accessed from the pool
 with the use() member function.  The size of the pool extends
 automatically if its initial limit is reached.  This pool is a
 linear pool, i.e. we can rely upon their index to be sequential.
 So in order to return a specific object into the pool's disposal,
 all objects having larger indices have to be free (like a reverse
 LIFO - last out first back). The free member function returns
 objects to the pool's disposal. Upon destruction, all pool objects
 are destroyed using their destructor.
 It does not make sense to have a copy constructor or assignment op.
<h1>Member Description</h1>
<h3><a name="LinPool:~LinPool(void)">~LinPool</a>( void )</h3>
 Destructor.
<p>
<h3><a name="LinPool:LinPool(size_t,size_t)">LinPool</a>( size_t capacity=0, size_t increment=0 )</h3>
<p>
 Default constructor: optionally specify initial capacity,
 reallocation increment, and whether the pointers are internal.
<p>
<h3>const T*&amp;	<a name="LinPool:operator()(size_t)const">operator ()</a>( size_t index ) const</h3>
<p>
 Efficient array operator (const version): no bounds checking.
<p>
<h3>T*&amp; <a name="LinPool:operator()(size_t)">operator ()</a>( size_t index )</h3>
<p>
<p>
 Efficient array operator (non-const version): no bounds checking.
<p>
<h3>const T*&amp;	<a name="LinPool:operator[](size_t)const">operator []</a>( size_t index ) const</h3>
<p>
<p>
 Bounds-checking array operator (const version): throws sxBoundsError.
<p>
<h3>T*&amp; <a name="LinPool:operator[](size_t)">operator []</a>( size_t index )</h3>
<p>
 Bounds-checking array operator (non-const version): throws sxBoundsError.
<p>
<h3>T*&amp; <a name="LinPool:use(void)">use</a>( void )</h3>
<p>
 use method: bounds-adjusting operator that returns the pool
 element as an lvalue to be used by the user. It is a combination
 of append() and at() of VarVec and PtrVec.  If the bounds of the
 pool array are reached, it is extended by increment_.
<p>
<h3>size_t	<a name="LinPool:length(void)const">length</a>( void ) const</h3>
<p>
 length method: returns current occupied length of the pool.
<p>
<h3>size_t	<a name="LinPool:free(size_t)">free</a>( size_t count = 0)</h3>
<p>
<p>
 free method: declare pool objects as free for new use.
 If no argument is given, all elements are free to use again.
 Else, the number of elements specified is freed up from the end.
<p>
<br>
<img SRC="rule.gif" >
<h6>
&copy;
<A HREF = "copyright.html">
Copyright
</A>
The Johns Hopkins University 1999, All Rights Reserved.<br>

<a href="mailto:kunszt@pha.jhu.edu">Peter Z. Kunszt</a>,
<br>
</h6>

</body>
</html>
</body>
</html>
