
;+
; NAME:
;  SDSS_GENRAND
;
;
; PURPOSE:
;  Generate random points for photometric or spectroscopic galaxies using
;  masks. For photometric galaxies, hierarchical pixel masks are used
;  (generated by Ryan Scranton).  For spectroscopic galaxies spherical polygons
;  are used, based on the tiling (generated by Max Tegmark).  One can also
;  apply the photometric mask to the spectroscopic random points with
;  /photmask.  Edge checking can also be performed for specgals (not yet
;  implemented).
;
;  NOTE: This code uses apply_sphpoly_mask.pro and apply_pixel_mask.pro. 
;        These routines call complied C code, which must be compiled before
;        running this program.  Also, the pixel code uses the gsl (gnu
;        scientific libraries) which must also be installed on the system.
;
;
; CATEGORY:
;  SDSS specific routine
;
;
; CALLING SEQUENCE:
;  sdss_genrand
;
;
; INPUTS:
;  stripes: For which stripes should be generate random points? e.g. [10,11,12]
;     nrand: number of random points.
;
;
; OPTIONAL INPUTS:
;  phot_maskfile: The mask file for the photometric pixel mask.
;  spec_maskfile: The mask file for the specgal spherical polygon mask.
;  primary_bound_array: the overall boundaray array for these stripes.  By default, the
;     boundary array is created from primary_bound_multi, stripes, each_bound,
;     bound_array. Note: Currently the pixel maks code implements bounds based
;     on the primary survey area.
;  angmax: max angle around each point to search for edges.  If this is sent,
;     edges are checked.  Only used if /photmask is also set.
;  compcut: A completeness cut for the specgal points.  Each point in the sky
;     has a completeness based on the existing spectroscopy. compcut=0 will
;     cover all the area observed spectroscopically, but not all
;     this area is complete.  By setting this to, say, 0.95, one gaurantees
;     that 95% of the target objects in each region actually has a spectra.
;     This avoids over-populating incomplete areas with lots of random points.
;     One should also apply this cut to the actual specgals used.
;
; KEYWORD PARAMETERS:
;  Types of masks:
;    /basic, /simple, /bound, /combined. See apply_pixel_mask for an
;    explanation. Default is /basic
;  /photmask: apply the boundary photometric mask to the spectra
;  /twoquad: when checking for edges (angmax is sent), use the two quadrant
;     check method.  In this case, a point is still ok if two adjacent
;     quadrants do not find an edge or hole.
;  /silent: Don't print anything (note the C programs print things anyway).
;
; OUTPUTS:
;  clambda, ceta: The random points in corrected lambda/eta coordinates.
;
;
; OPTIONAL OUTPUTS:
;  edgeflag=edgeflag: will be returned if edges are checked.
;  maskflags=: Flags from the mask code.
;
;
;
; EXAMPLES:
;  * To generate spectro objects with completeness greater than 0.9
;  stripes = [10,11,12]
;  nrand = 100000
;  compcut=0.9
;  sdss_genrand, stripes, nrand, clambda, ceta, /spec, compcut=compcut
;
;  * To generate with a cut on the photometric masks:
;  sdss_genrand, stripes, nrand, clambda, ceta, /spec, /photmask
;
;  * To check for edges against the photometric mask
;  angmax = replicate(0.2, nrand)  ;degrees
;  sdss_genrand, stripes, nrand, clambda, ceta, /spec, /photmask, angmax=angmax
;
;  * To generate random points from the photometric mask, not including the
;  * combined or "junk" masks
;  sdss_genrand, stripes, nrand, clambda, ceta
;
;  * To include the junk masks
;  sdss_genrand, stripes, nrand, clambda, ceta, /combined
;
; EXTERNAL ROUTINES:
;
;  primary_bound_multi.pro
;        |-> primary_bound.pro
;  apply_sphpoly_mask.pro
;        |-> sphpoly_completeness.pro
;  apply_pixel_mask.pro
;
;  arrscl.pro
;
; MODIFICATION HISTORY:
;  Created: 25-May-2003 Erin Scott Sheldon
;
;-
;
;
;
;  Copyright (C) 2005  Erin Sheldon, NYU.  erin dot sheldon at gmail dot com
;
;    This program is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program; if not, write to the Free Software
;    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
;
;                                       


PRO sdss_genrand_apply_pbcuts, stripes, clambda, ceta, masked, unmasked

  IF n_params() LT 3 THEN BEGIN 
      print,'-Syntax: apply_primary_bound_cuts, stripes/bound_array, clambda, ceta, masked, unmasked'
      return
  ENDIF 

  IF size(stripes,/tname) EQ 'STRUCT' THEN BEGIN 
      bound_array = stripes 
  ENDIF ELSE BEGIN 
      primary_bound_multi, stripes, bound_array, overall_bound
  ENDELSE 

  nst = n_elements(stripes)
  nobj = n_elements(clambda)

  testarr = intarr(nobj)

  FOR i=0L, nst-1 DO BEGIN 
      good = where( (clambda GE bound_array[i].lammin) AND $
                    (clambda LE bound_array[i].lammax) AND $
                    (ceta GE bound_array[i].etamin) AND $
                    (ceta LE bound_array[i].etamax), $
                    ngood, comp=bad, ncomp=nbad)

      IF ngood NE 0 THEN BEGIN 
          testarr[good] = 1
      ENDIF 

  ENDFOR 
  
  unmasked = where(testarr NE 0, ncomp=ncomp, comp=masked)

END 

PRO sdss_genrand_generate, num, bound_array, overall_bound, lambda, eta

  ;; generate uniformly in sin(lambda) and eta
  sinflam = sin( overall_bound.lammin*!d2r )
  sinllam = sin( overall_bound.lammax*!d2r )
  
  nbad = num
  ngood = 0L

  lambda = dblarr(num)
  eta = dblarr(num)
  
  bad = lindgen(num)

  WHILE ngood LT num DO BEGIN 

      slambda = arrscl( randomu(seed, nbad, /double), $
                        sinflam, sinllam, $
                        arrmin=0., arrmax=1.)
      
      tlambda = asin(temporary(slambda))*!r2d
          
      teta = arrscl(randomu(seed, nbad, /double), $
                    overall_bound.etamin, overall_bound.etamax, $
                    arrmin=0., arrmax=1.)

      sdss_genrand_apply_pbcuts, bound_array, tlambda, teta, $
        tbad, tgood

      IF tgood[0] NE -1 THEN BEGIN 
          lambda[bad[tgood]] = tlambda[tgood]
          eta[bad[tgood]] = teta[tgood]
          
          ngood = ngood + n_elements(tgood)
          
          IF tbad[0] NE -1 THEN BEGIN 
              bad = bad[tbad]
              nbad = n_elements(bad)
          ENDIF ELSE nbad=0L
      ENDIF 

  ENDWHILE 


END 

PRO sdss_genrand_photgal, stripes, nrand, lambda, eta, $
                          silent=silent, $
                          phot_maskfile=phot_maskfile,$
                          $
                          basic=basic, simple=simple, $
                          bound=bound, combined=combined, $
                          $
                          primary_bound_overall=primary_bound_overall, $
                          primary_bound_array=primary_bound_array


  IF (n_elements(primary_bound_overall) EQ 0 OR $
      n_elements(primary_bound_array)   EQ 0 ) THEN BEGIN 
      primary_bound_multi, stripes, primary_bound_array, primary_bound_overall
  ENDIF

  ngood = 0L

  lambda = dblarr(nrand)
  eta    = dblarr(nrand)

  bad = lindgen(nrand)

  nbad = nrand

  WHILE ngood LT nrand DO BEGIN 
      
      IF NOT keyword_set(silent) THEN BEGIN 
          IF ngood EQ 0 THEN BEGIN 
              print
              print,'** Generating ',ntostr(nbad) 
              psilent = 0
          ENDIF ELSE BEGIN 
              print
              print,'** Re-Generating ',ntostr(nbad)
              psilent = 1
          ENDELSE 
      ENDIF ELSE psilent=1
      
      IF nbad EQ 0 THEN stop
      sdss_genrand_generate, $
        nbad, primary_bound_array, primary_bound_overall, $
        tmplam,tmpeta

      ;; now apply the pixel mask, just bound
      apply_pixel_mask, tmplam, tmpeta, tbad, tgood, $
        basic=basic, simple=simple, $
        bound=bound, combined=combined, $
        maskfile=phot_maskfile, $
        silent=psilent
 
      IF tgood[0] NE -1 THEN BEGIN 
                        
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ;; we found some good ones: this will subscript the
          ;; new good ones in lambda, eta
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

          good_ids = bad[tgood]
              
          ;; copy in the good ones
          lambda[good_ids] = tmplam[tgood]
          eta[good_ids]    = tmpeta[tgood]
              
          ;; how many good ones now?
          ngood = ngood + n_elements(tgood)
              
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ;; now set bad ones to the ones that failed this
          ;; time around, or to zero if we are finished
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

          IF tbad[0] NE -1 THEN BEGIN 
              bad = bad[tbad]
              nbad = n_elements(bad)
          ENDIF ELSE nbad=0L
              
      ENDIF 
       
  ENDWHILE 

  ;; lambda's emerge unsorted

END 

PRO sdss_genrand_specgal, stripes, nrand, lambda, eta, $
                          silent=silent, $
                          phot_maskfile=phot_maskfile,$
                          spec_maskfile=spec_maskfile,$
                          $
                          primary_bound_overall=primary_bound_overall, $
                          primary_bound_array=primary_bound_array, $
                          $
                          compcut=compcut, $
                          photmask=photmask, $
                          combined=combined, $
                          twoquad=twoquad, $
                          angmax=angmax, $
                          maskflags=maskflags, $
                          completeness=completeness

  IF n_elements(primary_bound_overall) EQ 0 OR n_elements(primary_bound_array) EQ 0 THEN BEGIN 
      primary_bound_multi, stripes, primary_bound_array, primary_bound_overall
  ENDIF

  ngood = 0L

  lambda = dblarr(nrand)
  eta    = dblarr(nrand)

  nang = n_elements(angmax)
  IF (nang NE 0) AND keyword_set(photmask) THEN BEGIN 
      IF nang NE nrand THEN message,'# of angmax must equal nrand'
      doedge = 1
  ENDIF ELSE doedge=0

  completeness = fltarr(nrand)
  IF doedge THEN maskflags = intarr(nrand)

  bad = lindgen(nrand)

  nbad = nrand

  WHILE ngood LT nrand DO BEGIN 
      
      IF NOT keyword_set(silent) THEN BEGIN 
          IF ngood EQ 0 THEN BEGIN 
              ;;print
              print,'** Generating ',ntostr(nbad) 
              psilent = 0
          ENDIF ELSE BEGIN 
              ;;print
              IF ngood NE ngood_old THEN BEGIN 
                  print,'** Re-Generating ',ntostr(nbad)
              ENDIF 
              psilent = 1
          ENDELSE 
      ENDIF ELSE psilent=1
      ngood_old = ngood

      IF nbad EQ 0 THEN stop
      sdss_genrand_generate, nbad, primary_bound_array, primary_bound_overall, $
                             tmplam,tmpeta

      ;; First apply spectroscopic mask
      tbadlist = bytarr(nbad)
      apply_sphpoly_mask, tmplam, tmpeta, tbad, tgood1, /lameta, $
                          compcut=compcut, maskfile = spec_maskfile, $
                          completeness = tcomp, silent=psilent
      IF tbad[0] NE -1 THEN tbadlist[tbad] = 1b

      IF tgood1[0] NE -1 THEN BEGIN 

          ;; should we also apply the photometric mask?
          IF keyword_set(photmask) THEN BEGIN 

              ;; now apply the pixel mask, just bound, with
              ;; edge checking on
              IF doedge THEN BEGIN 

                  tangmax = angmax[bad[tgood1]]
                  apply_pixel_mask, tmplam[tgood1], tmpeta[tgood1], $
                                    tbad2, tgood2, tmaskflags, $
                                    maxangle=tangmax, $
                                    combined=combined, $
                                    twoquad=twoquad, $
                                    maskfile=phot_maskfile, silent=psilent

              ENDIF ELSE BEGIN 

                  ;; now apply the pixel mask, just bound
                  apply_pixel_mask, tmplam[tgood1], tmpeta[tgood1], $
                                    tbad2, tgood2, maskfile=phot_maskfile, $
                                    combined=combined, silent=psilent
                  
              ENDELSE 

              IF tbad2[0] NE -1 THEN tbadlist[tgood1[tbad2]] = 1b
              tbad = where(tbadlist EQ 1b)

              IF tgood2[0] NE -1 THEN BEGIN 
                  tgood = tgood1[tgood2] 
              ENDIF ELSE BEGIN 
                  tgood = -1
              ENDELSE 

          ENDIF ELSE BEGIN 
              tgood = tgood1
          ENDELSE 

          IF tgood[0] NE -1 THEN BEGIN 
                        
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              ;; we found some good ones: this will subscript the
              ;; new good ones in lambda, eta
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              good_ids = bad[tgood]
              
              ;; copy in the good ones
              lambda[good_ids] = tmplam[tgood]
              eta[good_ids]    = tmpeta[tgood]
              IF doedge THEN maskflags[good_ids] = tmaskflags[tgood2]
              completeness[good_ids] = tcomp[tgood]

              ;; how many good ones now?
              ngood = ngood + n_elements(tgood)
              
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              ;; now set bad ones to the ones that failed this
              ;; time around, or to zero if we are finished
              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

              IF tbad[0] NE -1 THEN BEGIN 
                  bad = bad[tbad]
                  nbad = n_elements(bad)
              ENDIF ELSE nbad=0L
              
          ENDIF 
      ENDIF 
  ENDWHILE 

  ;; lambda's emerge unsorted


END 



PRO sdss_genrand, stripes, nrand, lambda, eta, $
                  silent=silent, $
                  phot_maskfile=phot_maskfile,$
                  spec_maskfile=spec_maskfile,$
                  primary_bound_overall=primary_bound_overall, $
                  primary_bound_array=primary_bound_array, $
                  $
                  basic=basic, simple=simple, $
                  bound=bound, combined=combined, $         
                  $
                  specgal=specgal, $
                  compcut=compcut, $
                  photmask=photmask, $
                  twoquad=twoquad, $
                  angmax=angmax, maskflags=maskflags, $
                  completeness=completeness

  IF n_params() LT 2 THEN BEGIN 
      print,'-Syntax: sdss_genrand, stripes, nrand, lambda, eta, $'
      print,'             /silent,                               $'
      print,'             phot_maskfile=phot_maskfile,           $'
      print,'             spec_maskfile=spec_maskfile,           $'
      print,'             primary_bound_overall=primary_bound_overall,           $'
      print,'             primary_bound_array=primary_bound_array,               $'
      print,'             $'
      print,'             /basic, /simple, /bound, /combined,    $'
      print,'             $'
      print,'             /specgal,                              $'
      print,'             compcut=compcut,                       $'
      print,'             /photmask,                             $'
      print,'             /twoquad,                              $'
      print,'             angmax=angmax,                         $'
      print,'             maskflags=maskflags,                   $'
      print,'             completeness=completeness'
      print
      print,'For photometric masking, default is /basic'
      return
  ENDIF 

  

  IF keyword_set(specgal) THEN BEGIN 
      
      message,'You need to update the photometric mask stuff for specgal'
      IF NOT keyword_set(silent) THEN BEGIN 
          print
          print,"Generating lambda's and eta's: "+ntostr(nrand)+$
                " From sphpoly masks"
      ENDIF 
      sdss_genrand_specgal, stripes, nrand, lambda, eta, $
        silent=silent, $
        phot_maskfile=phot_maskfile,$
        spec_maskfile=spec_maskfile,$
        $
        primary_bound_overall=primary_bound_overall, $
        primary_bound_array=primary_bound_array, $
        $
        compcut=compcut, $
        photmask=photmask, $
        combined=combined, $
        twoquad=twoquad, $
        angmax=angmax, $
        maskflags=maskflags, $
        completeness=completeness
      
  ENDIF ELSE BEGIN 

      IF NOT keyword_set(silent) THEN BEGIN 
          print
          print,"Generating lambda's and eta's: "+ntostr(nrand)+$
                " From photometric masks"
      ENDIF 
      sdss_genrand_photgal, stripes, nrand, lambda, eta, $
        silent=silent, $
        phot_maskfile=phot_maskfile,$
        $
        primary_bound_overall=primary_bound_overall, $
        primary_bound_array=primary_bound_array, $
        $
        basic=basic, simple=simple, $
        bound=bound, combined=combined

  ENDELSE 

  return

END 
